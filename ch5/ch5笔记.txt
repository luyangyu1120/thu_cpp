5.1  标识符的作用域与可见性
    1  函数原型作用域
        形参表的()之内
        double area (double radius)
        形参radius的作用域就是在(double radius)的括号内
    2  局部作用域 快作用域
        在函数体之内{}都是形参的作用域
        void fun(int a){  /从此开始定义了a 整个 函数的{}都是a的作用域
            int  b = a; //从这开始定义了b 所以从此之后就是形参b的作用域
            cin >> b;
            if(b>0){
                int c; ... //这个{}是形参c的作用域
                }
        }
    3  类作用域
        类的成员都有类作用域 范围包括类体内部和成员函数体 成员函数的实现可能在类的外部 但是也是作用域的一部分
        在类作用域以外访问类的成员包括两种
            1 静态成员：通过类名、或者该类的对象名、对象引用访问
            2 非静态成员  通过类名、或者该类的对象名、对象引用、对象指针访问
    4  文件作用域
        静态多用于 
        开始点是从声明点 结束于文件结束的地方
    5  命名空间作用域（ch10）
    6  可见性
    例子
        #include<iostream>
        using namespace std;
        int i; //全局变量 文件作用域
        int main(){
            i=5; //把全局变量i赋值为5
            {
                int i; //i是局部变量 
                i = 7;
                cout << "i = " << i <<endl; //输出结果为7
                //因为和全局变量i重名 但是这个i只在这个小括号里面有用
                //在执行完这个{}之后 这个i的内存空间就消亡了
            }
            cout << "i = " << i <<endl; //输出结果为5
            //上面{}的i消亡之后 i还是那个全局变量 在整个文件中都起作用
            return 0;
        }


5.2  对象的生存期
    1  静态生存期
        这种生存期与程序的运行期相同。程序运行结束才消失
        在文件作用域中声明的对象具有这种生存期。
        在函数内部声明静态生存期对象，要冠以关键字static 。
        在整个程序运行期间 其值都不会改变 即使对象离开其作用域 除非主动做了一些修改

    2  动态生存期
        块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）。
        开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。
        一旦离开作用域 其值消亡

    3 例子
        //例5-2变量的生存期与可见性
        #include <iostream>
        using namespace std;
        int i = 1; // i 为全局变量，具有静态生存期。
        void other()
        {
            static int a = 2;
            static int b; //默认初始值为0
            // a,b为静态局部变量，具有全局寿命，局部可见。即使离开other这个函数 他的内存空间也不会被释放
            //只要ab的值不被再次改变 在整个文件中 ab都保持原状
            //第一次调用other这个函数的时候 对a初始化为2 但是再次调用other这个函数的时候 就不会再对a进行初始化 因为此时a已经有值了
            //只第一次进入函数时被初始化。
            int c = 10; // C为局部变量，具有动态生存期，
            //每次进入函数时都初始化。
            a += 2; i += 32; c += 5;
            cout << "---OTHER---\n";
            cout << " i: " << i << " a: " << a << " b: " << b << " c: " << c << endl;
            b = a;
        }
        int main()
        {
            static int a; //静态局部变量，有全局寿命，局部可见。默认是0
            int b = -10;  // b, c为局部变量，具有动态生存期。
            int c = 0;
            cout << "---MAIN---\n";
            cout << " i: " << i << " a: " << a << " b: " << b << " c: " << c << endl;
            c += 8;
            other();
            cout << "---MAIN---\n";
            cout << " i: " << i << " a: " << a << " b: " << b << " c: " << c << endl;
            i += 10;
            other();
            return 0;
        }
        /*
        例5-2（续）
        运行结果：
        ---MAIN---
        i: 1 a: 0 b: -10 c: 0
        ---OTHER---
        i: 33 a: 4 b: 0 c: 15 //other函数内的abc
        ---MAIN---
        i: 33 a: 0 b: -10 c: 8
        ---OTHER---
        i: 75 a: 6 b: 4 c: 15
        */

5.3  类的静态成员
    1  静态数据成员

        用关键字static声明
        为该类的所有对象共享，静态数据成员具有静态生存期。
        必须在类外定义和初始化，用(::)来指明所属的类。
        例子 0501.cpp

    2  静态函数成员
        例子 0502.cpp

5.4  类的友元
    1  类的友元
        友元是C++提供的一种破坏数据封装和数据隐藏的机制。
        通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。
        可以使用友元函数和友元类。
        为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。
    2  友元函数
        友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected成员
        作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。
        访问对象中的成员必须通过对象名。访问哪个对象 
    3  例子0503.cpp
    4  友元类
        若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。
        声明语法：将友元类名在另一个类中使用friend修饰说明。
        例子0503.cpp

5.5  共享数据的保护
    1 既想要共享数据 又不希望共享的数据被修改 保证安全性
    在使用对象的引用进行运算的时候 由于引用是双向的数据传送 所以引用有修改原始数据的风险

    2 共享数据的保护

        对于既需要共享、又需要防止改变的数据应该声明为常类型（用const进行修饰）。
        对于不改变对象状态的成员函数应该声明为常函数。

    3 常类型

        1 常对象：必须进行初始化,不能被更新。

            const 类名 对象名
            例子
            class A
            {
            public:
                A(int i,int j) {x=i; y=j;}
                                ...
            private:
                int x,y;
            };
            A const a(3,4); //a是常对象，不能被更新 

        2 常成员

            用const进行修饰的类成员：常数据成员和常函数成员
                常成员函数 0504.cpp
                常数据成员 0505.cpp

        3 常引用：被引用的对象不能被更新。

            const  类型说明符  &引用名

        4 常数组：数组元素不能被更新(详见第6章)。
            类型说明符  const  数组名[大小]...

        5 常指针：指向常量的指针(详见第6章)。



5.6  多文件结构和编译预处理命令
    1 C++程序的一般组织结构

        一个工程可以划分为多个源文件：

            类声明文件（.h文件）

            类实现文件（.cpp文件）

            类的使用文件（main()所在的.cpp文件）

        利用工程来组合各个文件。

    2  外部变量

        如果一个变量除了在定义它的源文件中可以使用外，还能被其它文件使用，那么就称这个变量是外部变量。

        文件作用域中定义的变量，默认情况下都是外部变量，但在其它文件中如果需要使用这一变量，需要用extern关键字加以声明。

    3  外部函数

        在所有类之外声明的函数（也就是非成员函数），都是具有文件作用域的。

        这样的函数都可以在不同的编译单元中被调用，只要在调用之前进行引用性声明（即声明函数原型）即可。
        也可以在声明函数原型或定义函数时用extern修饰，其效果与不加修饰的默认状态是一样的。

    4  将变量和函数限制在编译单元内
        当前文件中定义的变量函数只能在当前文件中使用

        使用匿名的命名空间：在匿名命名空间中定义的变量和函数，都不会暴露给其它的编译单元。

        namespace {         //匿名的命名空间
                int n;
                void f() {
                            n++;
                }
        }
        这里被“namespace { …… }”括起的区域都属于匿名的命名空间。

    5  标准C++库

        标准C++类库是一个极为灵活并可扩展的可重用软件模块的集合。
        标准C++类与组件在逻辑上分为6种类型：

            输入/输出类

            容器类与抽象数据类型 容器类存储大批量的数据

            存储管理类

            算法

            错误处理

            运行环境支持

    6  编译预处理

        #include 包含指令

            将一个源文件嵌入到当前源文件中该点处。

            #include<文件名> 

                –  按标准方式搜索，文件位于C++系统目录的include子目录下
            #include"文件名"

                –  首先在当前目录中搜索，若没有，再按标准方式搜索。

        #define 宏定义指令

            定义符号常量，很多情况下已被const定义语句取代。

            定义带参数宏，已被内联函数取代。

        #undef

            删除由#define定义的宏，使之不再起作用。


